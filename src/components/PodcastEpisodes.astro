---
interface Episode {
    title: string;
    pubDate: string;
    link: string;
    description: string;
    audioUrl?: string;
    duration?: string;
    imageUrl?: string;
}

export interface Props {
    rssFeedUrl: string;
    episodesPerPage?: number;
}

const { rssFeedUrl, episodesPerPage = 5 } = Astro.props;

// Fetch all episodes at build time
async function getPodcastEpisodes(feedUrl: string): Promise<Episode[]> {
    try {
        const response = await fetch(feedUrl);
        if (!response.ok) throw new Error(`Failed to fetch RSS feed: ${response.status}`);

        const xmlText = await response.text();
        const episodes: Episode[] = [];

        // Better parsing that handles CDATA and HTML entities
        const itemRegex = /<item>([\s\S]*?)<\/item>/gi;
        const items = xmlText.match(itemRegex) || [];

        for (const item of items) {
            // Extract title - handle CDATA sections
            let title = '';
            const titleMatch = item.match(/<title>([\s\S]*?)<\/title>/i);
            if (titleMatch) {
                title = titleMatch[1].trim();
                // Remove CDATA wrappers if present
                title = title.replace(/<!\[CDATA\[(.*?)\]\]>/g, '$1');
            }

            // Extract description - handle CDATA and HTML
            let description = '';
            const descriptionMatch = item.match(/<description>([\s\S]*?)<\/description>/i);
            if (descriptionMatch) {
                description = descriptionMatch[1].trim();
                // Remove CDATA wrappers if present
                description = description.replace(/<!\[CDATA\[(.*?)\]\]>/g, '$1');
            }

            // Extract other fields
            const pubDateMatch = item.match(/<pubDate>([\s\S]*?)<\/pubDate>/i);
            const linkMatch = item.match(/<link>([\s\S]*?)<\/link>/i);
            const enclosureMatch = item.match(/<enclosure[^>]*url="([^"]*)"[^>]*>/i);
            const durationMatch = item.match(/<itunes:duration>([\s\S]*?)<\/itunes:duration>/i);
            const imageMatch = item.match(/<itunes:imageUrl>([\s\S]*?)<\/itunes:imageUrl>/i);

            if (title && pubDateMatch) {
                episodes.push({
                    title: title,
                    pubDate: pubDateMatch[1].trim(),
                    link: linkMatch ? linkMatch[1].trim() : '',
                    description: description,
                    audioUrl: enclosureMatch ? enclosureMatch[1] : undefined,
                    duration: durationMatch ? durationMatch[1].trim() : undefined,
                    imageUrl: imageMatch ? imageMatch[1] : undefined
                });
            }
        }

        episodes.sort((a, b) => new Date(b.pubDate).getTime() - new Date(a.pubDate).getTime());
        return episodes;
    } catch (error) {
        console.error('Error fetching podcast episodes:', error);
        return [];
    }
}

const allEpisodes = await getPodcastEpisodes(rssFeedUrl);
const totalEpisodes = allEpisodes.length;
const totalPages = Math.ceil(totalEpisodes / episodesPerPage);

// Create a cleaned version for display
const cleanedEpisodes = allEpisodes.map(episode => ({
    ...episode,
    // Clean HTML entities and tags for display
    title: cleanText(episode.title),
    description: cleanText(episode.description)
}));

// Helper function to clean text
function cleanText(text: string): string {
    if (!text) return '';

    // Decode HTML entities
    let cleaned = text
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&quot;/g, '"')
        .replace(/&#039;/g, "'")
        .replace(/&nbsp;/g, ' ');

    // Remove any remaining HTML tags but preserve line breaks
    cleaned = cleaned.replace(/<br\s*\/?>/gi, '\n');
    cleaned = cleaned.replace(/<[^>]*>/g, '');

    return cleaned.trim();
}

// Serialize for client-side
const serializedEpisodes = JSON.stringify(cleanedEpisodes);
---

<div id="podcast-pagination-container">
    <!-- Hidden data storage -->
    <div id="podcast-data"
         data-episodes={serializedEpisodes}
         data-episodes-per-page={episodesPerPage}
         data-total-episodes={totalEpisodes}
         data-total-pages={totalPages}
         style="display: none;">
    </div>

    <!-- Initial render of first page -->
    <div class="podcast-section">
        <h2>
            <font face="Arial" color="#0000FF" size="5">
                üìª Podcast Episodes
                <span id="page-indicator" class="episode-count">(Page 1 of {totalPages})</span>
            </font>
        </h2>

        <div id="episodes-container">
            <!-- Server-side rendered first page for better initial load -->
            {cleanedEpisodes.slice(0, episodesPerPage).map((episode, index) => (
                    <div class="episode-item">
                        {/* Episode Image */}
                        <p>??????????</p>
                        {episode.imageUrl && (
                                <div class="episode-image">
                                    <img src={episode.imageUrl} alt={episode.imageUrl} loading="lazy" />
                                    <p>!!!!!</p>
                                </div>
                        )}

                        <div class="episode-content">
                            <h3 class="episode-title">
                                <a href={episode.link || episode.audioUrl || '#'} target="_blank" rel="noopener">
                                    {episode.title || 'Untitled Episode'}
                                </a>
                            </h3>

                            <div class="episode-meta">
              <span class="episode-date">
                üóìÔ∏è <strong>Released:</strong> {new Date(episode.pubDate).toLocaleDateString()}
              </span>

                                {episode.duration && (
                                        <span class="episode-duration">
                  ‚è±Ô∏è <strong>Duration:</strong> {episode.duration}
                </span>
                                )}
                            </div>

                            {episode.description && (
                                    <div class="episode-description">
                                        {episode.description.substring(0, 800)}
                                        {episode.description.length > 800 ? '...' : ''}
                                    </div>
                            )}
                            {episode.audioUrl && (
                                    <div class="episode-audio">
                                        <audio controls style="width: 100%; max-width: 400px; height: 30px;">
                                            <source src={episode.audioUrl} type="audio/mpeg" />
                                            Your browser does not support the audio element.
                                        </audio>
                                    </div>
                            )}
                        </div>

                        <hr class="episode-divider" />
                    </div>
            ))}
        </div>

        <!-- Pagination Controls -->
        {totalPages > 1 && (
                <div class="pagination" id="pagination-controls">
                    <button class="pagination-link pagination-first" id="first-page">
                        &lt;&lt; First
                    </button>

                    <button class="pagination-link pagination-prev" id="prev-page">
                        &lt; Prev
                    </button>

                    <div id="page-numbers" class="page-numbers">
                        <!-- Page numbers will be generated by JavaScript -->
                    </div>

                    <button class="pagination-link pagination-next" id="next-page">
                        Next &gt;
                    </button>

                    <button class="pagination-link pagination-last" id="last-page">
                        Last &gt;&gt;
                    </button>
                </div>
        )}

        <div class="episode-info">
            <font size="2" face="Arial">
                Showing episodes <span id="episode-range">1-{Math.min(episodesPerPage, totalEpisodes)}</span> of {totalEpisodes} total episodes
            </font>
        </div>
    </div>
</div>

<script>
    // Podcast pagination - using DOM methods to avoid template literal issues
    document.addEventListener('DOMContentLoaded', function() {
        // Get data from hidden element
        const dataElement = document.getElementById('podcast-data');
        if (!dataElement) {
            console.error('Podcast data element not found');
            return;
        }

        const podcastData = {
            episodes: JSON.parse(dataElement.dataset.episodes),
            episodesPerPage: parseInt(dataElement.dataset.episodesPerPage),
            totalEpisodes: parseInt(dataElement.dataset.totalEpisodes),
            totalPages: parseInt(dataElement.dataset.totalPages)
        };

        let currentPage = 1;

        function initializePagination() {
            // Set initial page from URL
            const urlParams = new URLSearchParams(window.location.search);
            const pageParam = urlParams.get('page');
            if (pageParam) {
                const page = parseInt(pageParam);
                if (page >= 1 && page <= podcastData.totalPages) {
                    currentPage = page;
                    // Only re-render if not on first page (first page is server-rendered)
                    if (page !== 1) {
                        renderEpisodes();
                    }
                }
            }

            renderPaginationControls();
            updateButtonStates();
            attachEventListeners();
        }

        function renderEpisodes() {
            const startIndex = (currentPage - 1) * podcastData.episodesPerPage;
            const endIndex = startIndex + podcastData.episodesPerPage;
            const currentEpisodes = podcastData.episodes.slice(startIndex, endIndex);

            const episodesContainer = document.getElementById('episodes-container');
            const pageIndicator = document.getElementById('page-indicator');
            const episodeRange = document.getElementById('episode-range');

            if (pageIndicator) {
                pageIndicator.textContent = `(Page ${currentPage} of ${podcastData.totalPages})`;
            }

            if (episodeRange) {
                episodeRange.textContent = `${startIndex + 1}-${Math.min(endIndex, podcastData.totalEpisodes)}`;
            }

            if (episodesContainer) {
                if (currentEpisodes.length === 0) {
                    episodesContainer.innerHTML = '<p>No episodes found.</p>';
                    return;
                }

                // Clear container
                episodesContainer.innerHTML = '';

                // Build episodes using DOM methods for safety
                currentEpisodes.forEach((episode, index) => {
                    const episodeItem = document.createElement('div');
                    episodeItem.className = 'episode-item';

                    // Add image if available
                    if (episode.imageUrl) {
                        const imageDiv = document.createElement('div');
                        imageDiv.className = 'episode-image';

                        const img = document.createElement('img');
                        img.src = episode.imageUrl;
                        img.alt = episode.title || 'Episode image';
                        img.loading = 'lazy';

                        imageDiv.appendChild(img);
                        episodeItem.appendChild(imageDiv);
                    }

                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'episode-content';

                    // Title
                    const title = document.createElement('h3');
                    title.className = 'episode-title';

                    const titleLink = document.createElement('a');
                    titleLink.href = episode.link || episode.audioUrl || '#';
                    titleLink.target = '_blank';
                    titleLink.rel = 'noopener';
                    titleLink.textContent = episode.title || 'Untitled Episode';
                    title.appendChild(titleLink);
                    contentDiv.appendChild(title);

                    // Meta information
                    const meta = document.createElement('div');
                    meta.className = 'episode-meta';

                    const dateSpan = document.createElement('span');
                    dateSpan.className = 'episode-date';
                    dateSpan.innerHTML = `üóìÔ∏è <strong>Released:</strong> ${episode.pubDate ? new Date(episode.pubDate).toLocaleDateString() : 'Unknown date'}`;
                    meta.appendChild(dateSpan);

                    if (episode.duration) {
                        const durationSpan = document.createElement('span');
                        durationSpan.className = 'episode-duration';
                        durationSpan.innerHTML = `‚è±Ô∏è <strong>Duration:</strong> ${episode.duration}`;
                        meta.appendChild(durationSpan);
                    }

                    contentDiv.appendChild(meta);

                    // Description - use innerHTML since we've already cleaned the HTML server-side
                    if (episode.description) {
                        const descriptionDiv = document.createElement('div');
                        descriptionDiv.className = 'episode-description';

                        let displayDescription = episode.description.substring(0, 800);
                        if (episode.description.length > 800) {
                            displayDescription += '...';
                        }

                        // Use innerHTML since the description has already been cleaned and is safe
                        descriptionDiv.innerHTML = displayDescription;
                        contentDiv.appendChild(descriptionDiv);
                    }

                    // Audio player
                    if (episode.audioUrl) {
                        const audioDiv = document.createElement('div');
                        audioDiv.className = 'episode-audio';

                        const audio = document.createElement('audio');
                        audio.controls = true;
                        audio.style.width = '100%';
                        audio.style.maxWidth = '400px';
                        audio.style.height = '30px';

                        const source = document.createElement('source');
                        source.src = episode.audioUrl;
                        source.type = 'audio/mpeg';

                        audio.appendChild(source);
                        audio.appendChild(document.createTextNode('Your browser does not support the audio element.'));
                        audioDiv.appendChild(audio);
                        contentDiv.appendChild(audioDiv);
                    }

                    episodeItem.appendChild(contentDiv);

                    // Divider
                    const divider = document.createElement('hr');
                    divider.className = 'episode-divider';
                    episodeItem.appendChild(divider);

                    episodesContainer.appendChild(episodeItem);
                });
            }
        }

        function renderPaginationControls() {
            const pageNumbersContainer = document.getElementById('page-numbers');
            if (!pageNumbersContainer) return;

            const maxVisiblePages = 5;
            let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
            let endPage = Math.min(podcastData.totalPages, startPage + maxVisiblePages - 1);

            if (endPage - startPage + 1 < maxVisiblePages) {
                startPage = Math.max(1, endPage - maxVisiblePages + 1);
            }

            pageNumbersContainer.innerHTML = '';

            for (let i = startPage; i <= endPage; i++) {
                const pageButton = document.createElement('button');
                pageButton.textContent = i;
                pageButton.className = `pagination-link ${i === currentPage ? 'pagination-active' : ''}`;
                pageButton.onclick = () => goToPage(i);
                pageNumbersContainer.appendChild(pageButton);
            }
        }

        function updateButtonStates() {
            const firstPageBtn = document.getElementById('first-page');
            const prevPageBtn = document.getElementById('prev-page');
            const nextPageBtn = document.getElementById('next-page');
            const lastPageBtn = document.getElementById('last-page');

            if (firstPageBtn) firstPageBtn.disabled = currentPage === 1;
            if (prevPageBtn) prevPageBtn.disabled = currentPage === 1;
            if (nextPageBtn) nextPageBtn.disabled = currentPage === podcastData.totalPages;
            if (lastPageBtn) lastPageBtn.disabled = currentPage === podcastData.totalPages;
        }

        function attachEventListeners() {
            const firstPageBtn = document.getElementById('first-page');
            const prevPageBtn = document.getElementById('prev-page');
            const nextPageBtn = document.getElementById('next-page');
            const lastPageBtn = document.getElementById('last-page');

            if (firstPageBtn) firstPageBtn.onclick = () => goToPage(1);
            if (prevPageBtn) prevPageBtn.onclick = () => goToPage(currentPage - 1);
            if (nextPageBtn) nextPageBtn.onclick = () => goToPage(currentPage + 1);
            if (lastPageBtn) lastPageBtn.onclick = () => goToPage(podcastData.totalPages);
        }

        function goToPage(page) {
            if (page < 1 || page > podcastData.totalPages) return;

            currentPage = page;
            renderEpisodes();
            renderPaginationControls();
            updateButtonStates();

            // Update URL without page reload
            const url = new URL(window.location);
            url.searchParams.set('page', page);
            window.history.pushState({}, '', url);
        }

        // Handle browser back/forward buttons
        window.addEventListener('popstate', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const pageParam = urlParams.get('page');
            const page = pageParam ? parseInt(pageParam) : 1;

            if (page !== currentPage && page >= 1 && page <= podcastData.totalPages) {
                currentPage = page;
                renderEpisodes();
                renderPaginationControls();
                updateButtonStates();
            }
        });

        // Initialize
        initializePagination();
    });
</script>

<style>
.podcast-section {
    margin: 2rem 0;
    padding: 1rem;
    background: #ffffff;
    border: 2px outset #c0c0c0;
    }

.episode-count {
    font-size: 0.8em;
    color: #666;
    }

.episodes-list {
    margin-top: 1rem;
    }

.episode-item {
    margin-bottom: 1.5rem;
    padding: 1rem;
    background: #f0f0f0;
    border: 1px inset #c0c0c0;
    display: flex;
    flex-direction: column;
    gap: 1rem;
    }

.episode-image {
    text-align: center;
    }

.episode-image img {
    max-width: 300px;
    max-height: 300px;
    width: auto;
    height: auto;
    border: 2px outset #c0c0c0;
    }

.episode-content {
    flex: 1;
    }

.episode-title {
    font-family: "Arial", sans-serif;
    margin-bottom: 0.5rem;
    }

.episode-title a {
    color: #0000FF;
    text-decoration: underline;
    font-size: 1.2rem;
    }

.episode-title a:hover {
    color: #FF0000;
    text-decoration: none;
    }

.episode-meta {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    margin-bottom: 0.5rem;
    font-size: 0.9rem;
    color: #666;
    }

.episode-description {
    margin: 0.5rem 0;
    line-height: 1.4;
    font-size: 0.95rem;
    max-height: 300px;
    overflow-y: auto;
    padding: 0.5rem;
    background: #ffffff;
    border: 1px inset #c0c0c0;
    }

/* Style the preserved HTML elements */
.episode-description p {
    margin-bottom: 0.75rem;
    }

.episode-description br {
    content: '';
    display: block;
    margin-bottom: 0.5rem;
    }

.episode-description strong,
.episode-description b {
    font-weight: bold;
    color: #0000FF;
    }

.episode-description em,
.episode-description i {
    font-style: italic;
    }

.episode-description u {
    text-decoration: underline;
    }

.episode-description a {
    color: #0000FF;
    text-decoration: underline;
    }

.episode-description a:hover {
    color: #FF0000;
    text-decoration: none;
    }

.episode-description ul,
.episode-description ol {
    margin: 0.5rem 0;
    padding-left: 1.5rem;
    }

.episode-description li {
    margin-bottom: 0.25rem;
    }

.episode-audio {
    margin: 0.5rem 0;
    }

.episode-divider {
    height: 1px;
    background: #0000FF;
    border: none;
    margin: 1rem 0 0 0;
    }

/* Pagination Styles */
.pagination {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin: 2rem 0 1rem 0;
    padding: 1rem;
    background: #f0f0f0;
    border: 1px inset #c0c0c0;
    }

.page-numbers {
    display: flex;
    gap: 0.5rem;
    }

.pagination-link {
    padding: 0.5rem 1rem;
    background: #ffffff;
    border: 2px outset #c0c0c0;
    color: #0000FF;
    text-decoration: none;
    font-family: "Arial", sans-serif;
    font-size: 0.9rem;
    cursor: pointer;
    transition: all 0.2s ease;
    }

.pagination-link:hover:not(:disabled) {
    background: #0000FF;
    color: #ffffff;
    text-decoration: none;
    border: 2px inset #c0c0c0;
    }

.pagination-link:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    }

.pagination-active {
    background: #0000FF;
    color: #ffffff;
    border: 2px inset #c0c0c0;
    font-weight: bold;
    }

.episode-info {
    text-align: center;
    margin-top: 1rem;
    padding: 0.5rem;
    background: #f0f0f0;
    border: 1px inset #c0c0c0;
    }

audio {
    filter: sepia(0.3) saturate(1.2);
    }

@media (max-width: 768px) {
    .episode-item {
    flex-direction: column;
    }

    .episode-image img {
    max-width: 100%;
    }

    .episode-meta {
    flex-direction: column;
    gap: 0.5rem;
    }

    .pagination {
    gap: 0.25rem;
    }

    .pagination-link {
    padding: 0.4rem 0.8rem;
    font-size: 0.8rem;
    }

    .episode-description {
    max-height: 200px;
    font-size: 0.9rem;
    }
    }

@media (min-width: 769px) {
    .episode-item {
    flex-direction: row;
    align-items: flex-start;
    }

    .episode-image {
    flex-shrink: 0;
    margin-right: 1rem;
    }

    .episode-image img {
    max-width: 200px;
    }
    }
</style>
---
interface Episode {
    title: string;
    pubDate: string;
    link: string;
    description: string;
    audioUrl?: string;
    duration?: string;
    imageUrl?: string;
}

export interface Props {
    rssFeedUrl: string;
    episodesPerPage?: number;
}

const { rssFeedUrl, episodesPerPage = 5 } = Astro.props;

// Enhanced image extraction function
function extractImageUrl(item, description) {
    // Try different RSS image formats in order of priority

    // 1. iTunes image with href attribute (most common for podcasts)
    const itunesImageHref = item.match(/<itunes:image[^>]*href="([^"]*)"[^>]*>/i);
    if (itunesImageHref && itunesImageHref[1]) {
        return itunesImageHref[1].trim();
    }

    // 2. iTunes image with nested url (less common)
    const itunesImageUrl = item.match(/<itunes:image[^>]*>[\s]*<url>([^<]*)<\/url>[\s]*<\/itunes:image>/i);
    if (itunesImageUrl && itunesImageUrl[1]) {
        return itunesImageUrl[1].trim();
    }

    // 3. Media thumbnail
    const mediaThumbnail = item.match(/<media:thumbnail[^>]*url="([^"]*)"[^>]*>/i);
    if (mediaThumbnail && mediaThumbnail[1]) {
        return mediaThumbnail[1].trim();
    }

    // 4. Media content (image type)
    const mediaContent = item.match(/<media:content[^>]*url="([^"]*)"[^>]*type="image\/(jpg|jpeg|png|gif|webp)"[^>]*>/i);
    if (mediaContent && mediaContent[1]) {
        return mediaContent[1].trim();
    }

    // 5. Enclosure with image type
    const enclosureImage = item.match(/<enclosure[^>]*url="([^"]*\.(jpg|jpeg|png|gif|webp))"[^>]*type="image\/(jpg|jpeg|png|gif|webp)"[^>]*>/i);
    if (enclosureImage && enclosureImage[1]) {
        return enclosureImage[1].trim();
    }

    // 6. Image tag in description
    const descImage = description.match(/<img[^>]*src="([^"]*)"[^>]*>/i);
    if (descImage && descImage[1]) {
        return descImage[1].trim();
    }

    return '';
}

// Fetch all episodes at build time
async function getPodcastEpisodes(feedUrl: string): Promise<Episode[]> {
    try {
        const response = await fetch(feedUrl);
        if (!response.ok) throw new Error(`Failed to fetch RSS feed: ${response.status}`);

        const xmlText = await response.text();
        const episodes: Episode[] = [];

        // Better parsing that handles CDATA and HTML entities
        const itemRegex = /<item>([\s\S]*?)<\/item>/gi;
        const items = xmlText.match(itemRegex) || [];

        for (const item of items) {
            // Extract title - handle CDATA sections
            let title = '';
            const titleMatch = item.match(/<title>([\s\S]*?)<\/title>/i);
            if (titleMatch) {
                title = titleMatch[1].trim();
                // Remove CDATA wrappers if present
                title = title.replace(/<!\[CDATA\[(.*?)\]\]>/g, '$1');
            }

            // Extract description - handle CDATA and HTML
            let description = '';
            const descriptionMatch = item.match(/<description>([\s\S]*?)<\/description>/i);
            if (descriptionMatch) {
                description = descriptionMatch[1].trim();
                // Remove CDATA wrappers if present
                description = description.replace(/<!\[CDATA\[(.*?)\]\]>/g, '$1');
            }

            // Extract image using enhanced parser
            const imageUrl = extractImageUrl(item, description);

            // Extract other fields
            const pubDateMatch = item.match(/<pubDate>([\s\S]*?)<\/pubDate>/i);
            const linkMatch = item.match(/<link>([\s\S]*?)<\/link>/i);
            const enclosureMatch = item.match(/<enclosure[^>]*url="([^"]*)"[^>]*>/i);
            const durationMatch = item.match(/<itunes:duration>([\s\S]*?)<\/itunes:duration>/i);

            if (title && pubDateMatch) {
                episodes.push({
                    title: title,
                    pubDate: pubDateMatch[1].trim(),
                    link: linkMatch ? linkMatch[1].trim() : '',
                    description: description,
                    audioUrl: enclosureMatch ? enclosureMatch[1] : undefined,
                    duration: durationMatch ? durationMatch[1].trim() : undefined,
                    imageUrl: imageUrl || undefined
                });
            }
        }

        episodes.sort((a, b) => new Date(b.pubDate).getTime() - new Date(a.pubDate).getTime());
        return episodes;
    } catch (error) {
        console.error('Error fetching podcast episodes:', error);
        return [];
    }
}

const allEpisodes = await getPodcastEpisodes(rssFeedUrl);
const totalEpisodes = allEpisodes.length;
const totalPages = Math.ceil(totalEpisodes / episodesPerPage);

// Create a cleaned version for display
const cleanedEpisodes = allEpisodes.map(episode => ({
    ...episode,
    // Clean title but preserve HTML in description
    title: cleanText(episode.title),
    description: cleanDescription(episode.description)
}));

// Helper function to clean text (for titles)
function cleanText(text: string): string {
    if (!text) return '';

    // Decode HTML entities
    let cleaned = text
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&quot;/g, '"')
        .replace(/&#039;/g, "'")
        .replace(/&nbsp;/g, ' ');

    // Remove any remaining HTML tags
    cleaned = cleaned.replace(/<[^>]*>/g, '');

    return cleaned.trim();
}

// Helper function to clean descriptions while preserving safe HTML
function cleanDescription(description: string): string {
    if (!description) return '';

    // Decode HTML entities first
    let cleaned = description
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&quot;/g, '"')
        .replace(/&#039;/g, "'")
        .replace(/&nbsp;/g, ' ')
        .replace(/&mdash;/g, '‚Äî')
        .replace(/&ndash;/g, '‚Äì')
        .replace(/&hellip;/g, '‚Ä¶');

    // Remove CDATA wrappers and trailing ]]>
    cleaned = cleaned.replace(/<!\[CDATA\[(.*?)\]\]>/g, '$1');
    cleaned = cleaned.replace(/\]\]>$/g, ''); // Remove trailing ]]>
    cleaned = cleaned.replace(/\s*\]\]>\s*$/g, ''); // Remove trailing ]]> with whitespace

    // Preserve safe HTML tags: p, br, strong, b, em, i, u, a, ul, ol, li
    // First, close any unclosed tags that might break the HTML
    cleaned = cleaned
        .replace(/<p>/gi, '<p>')
        .replace(/<br>/gi, '<br>')
        .replace(/<br\s*\/>/gi, '<br>')
        .replace(/<strong>/gi, '<strong>')
        .replace(/<\/strong>/gi, '</strong>')
        .replace(/<b>/gi, '<b>')
        .replace(/<\/b>/gi, '</b>')
        .replace(/<em>/gi, '<em>')
        .replace(/<\/em>/gi, '</em>')
        .replace(/<i>/gi, '<i>')
        .replace(/<\/i>/gi, '</i>')
        .replace(/<u>/gi, '<u>')
        .replace(/<\/u>/gi, '</u>');

    // Handle links - ensure they have proper attributes
    cleaned = cleaned.replace(
        /<a\s+([^>]*)>/gi,
        '<a $1 target="_blank" rel="noopener noreferrer">'
    );

    return cleaned.trim();
}

// Create a new function that prepares the display version
function prepareDisplayDescription(description: string): string {
    const cleaned = cleanDescription(description);
    let display = cleaned.substring(0, 5000);
    if (cleaned.length > 5000) {
        display += '...';
    }
    return display;
}

// Serialize for client-side
const serializedEpisodes = JSON.stringify(cleanedEpisodes);
---

<div id="podcast-pagination-container">
    <!-- Hidden data storage -->
    <div id="podcast-data"
         data-episodes={serializedEpisodes}
         data-episodes-per-page={episodesPerPage}
         data-total-episodes={totalEpisodes}
         data-total-pages={totalPages}
         style="display: none;">
    </div>

    <!-- Initial render of first page -->
    <div class="podcast-section">
        <h2>
            <font face="Arial" color="#0000FF" size="5">
                <img src="./images/dancingMic.gif"/> Podcast Episodes <img src="./images/dancingMic.gif"/>
                <span id="page-indicator" class="episode-count">(Page 1 of {totalPages})</span>
            </font>
        </h2>

        <div id="episodes-container">
            <!-- Server-side rendered first page for better initial load -->
            {cleanedEpisodes.slice(0, episodesPerPage).map((episode, index) => (
                    <div class="episode-item">
                        {/* Header block with image and title */}
                        <div class="episode-header">
                            {episode.imageUrl && (
                                    <div class="episode-image">
                                        <img src={episode.imageUrl} alt={episode.title} loading="lazy" />
                                    </div>
                            )}
                            <h3 class="episode-title">
                                    {episode.title || 'Untitled Episode'}
                            </h3>
                        </div>

                        {/* Content block with meta, description, and audio */}
                        <div class="episode-content">
                            <div class="episode-meta">
              <span class="episode-date">
                üóìÔ∏è <strong>Released:</strong> {new Date(episode.pubDate).toLocaleDateString()}
              </span>

                                {episode.duration && (
                                        <span class="episode-duration">
                  ‚è±Ô∏è <strong>Duration:</strong> {episode.duration}
                </span>
                                )}
                            </div>

                            {episode.description && (
                                    <div class="episode-description" set:html={prepareDisplayDescription(episode.description)} />
                            )}

                            {episode.audioUrl && (
                                    <div class="episode-audio">
                                        <audio controls>
                                            <source src={episode.audioUrl} type="audio/mpeg" />
                                            Your browser does not support the audio element.
                                        </audio>
                                    </div>
                            )}
                        </div>

                        <hr class="episode-divider" />
                    </div>
            ))}
        </div>

        <!-- Pagination Controls and episode-info remain the same -->
        {totalPages > 1 && (
                <div class="pagination" id="pagination-controls">
                    <button class="pagination-link pagination-first" id="first-page">
                        &lt;&lt; First
                    </button>

                    <button class="pagination-link pagination-prev" id="prev-page">
                        &lt; Prev
                    </button>

                    <div id="page-numbers" class="page-numbers">
                        <!-- Page numbers will be generated by JavaScript -->
                    </div>

                    <button class="pagination-link pagination-next" id="next-page">
                        Next &gt;
                    </button>

                    <button class="pagination-link pagination-last" id="last-page">
                        Last &gt;&gt;
                    </button>
                </div>
        )}

        <div class="episode-info">
            <font size="2" face="Arial">
                Showing episodes <span id="episode-range">1-{Math.min(episodesPerPage, totalEpisodes)}</span> of {totalEpisodes} total episodes
            </font>
        </div>
    </div>
</div>

<script>
    // Podcast pagination - using DOM methods to avoid template literal issues
    document.addEventListener('DOMContentLoaded', function() {
        // Get data from hidden element
        const dataElement = document.getElementById('podcast-data');
        if (!dataElement) {
            console.error('Podcast data element not found');
            return;
        }

        const podcastData = {
            episodes: JSON.parse(dataElement.dataset.episodes),
            episodesPerPage: parseInt(dataElement.dataset.episodesPerPage),
            totalEpisodes: parseInt(dataElement.dataset.totalEpisodes),
            totalPages: parseInt(dataElement.dataset.totalPages)
        };

        let currentPage = 1;

        function initializePagination() {
            // Set initial page from URL
            const urlParams = new URLSearchParams(window.location.search);
            const pageParam = urlParams.get('page');
            if (pageParam) {
                const page = parseInt(pageParam);
                if (page >= 1 && page <= podcastData.totalPages) {
                    currentPage = page;
                    // Only re-render if not on first page (first page is server-rendered)
                    if (page !== 1) {
                        renderEpisodes();
                    }
                }
            }

            renderPaginationControls();
            updateButtonStates();
            attachEventListeners();
        }

        function renderEpisodes() {
            const startIndex = (currentPage - 1) * podcastData.episodesPerPage;
            const endIndex = startIndex + podcastData.episodesPerPage;
            const currentEpisodes = podcastData.episodes.slice(startIndex, endIndex);

            const episodesContainer = document.getElementById('episodes-container');
            const pageIndicator = document.getElementById('page-indicator');
            const episodeRange = document.getElementById('episode-range');

            if (pageIndicator) {
                pageIndicator.textContent = `(Page ${currentPage} of ${podcastData.totalPages})`;
            }

            if (episodeRange) {
                episodeRange.textContent = `${startIndex + 1}-${Math.min(endIndex, podcastData.totalEpisodes)}`;
            }

            if (episodesContainer) {
                if (currentEpisodes.length === 0) {
                    episodesContainer.innerHTML = '<p>No episodes found.</p>';
                    return;
                }

                // Clear container
                episodesContainer.innerHTML = '';

                // Build episodes using DOM methods for safety
                currentEpisodes.forEach((episode, index) => {
                    const episodeItem = document.createElement('div');
                    episodeItem.className = 'episode-item';

                    // Create header block with image and title
                    const headerDiv = document.createElement('div');
                    headerDiv.className = 'episode-header';

                    // Add image if available
                    if (episode.imageUrl) {
                        const imageDiv = document.createElement('div');
                        imageDiv.className = 'episode-image';

                        const img = document.createElement('img');
                        img.src = episode.imageUrl;
                        img.alt = episode.title || 'Episode image';
                        img.loading = 'lazy';

                        imageDiv.appendChild(img);
                        headerDiv.appendChild(imageDiv);
                    }

                    // Title
                    const title = document.createElement('h3');
                    title.className = 'episode-title';

                    const titleLink = document.createElement('a');
                    titleLink.href = episode.link || episode.audioUrl || '#';
                    titleLink.target = '_blank';
                    titleLink.rel = 'noopener';
                    titleLink.textContent = episode.title || 'Untitled Episode';
                    title.appendChild(titleLink);
                    headerDiv.appendChild(title);

                    episodeItem.appendChild(headerDiv);

                    // Create content block with meta, description, and audio
                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'episode-content';

                    // Meta information
                    const meta = document.createElement('div');
                    meta.className = 'episode-meta';

                    const dateSpan = document.createElement('span');
                    dateSpan.className = 'episode-date';
                    dateSpan.innerHTML = `üóìÔ∏è <strong>Released:</strong> ${episode.pubDate ? new Date(episode.pubDate).toLocaleDateString() : 'Unknown date'}`;
                    meta.appendChild(dateSpan);

                    if (episode.duration) {
                        const durationSpan = document.createElement('span');
                        durationSpan.className = 'episode-duration';
                        durationSpan.innerHTML = `‚è±Ô∏è <strong>Duration:</strong> ${episode.duration}`;
                        meta.appendChild(durationSpan);
                    }

                    contentDiv.appendChild(meta);

                    // Description
                    if (episode.description) {
                        const descriptionDiv = document.createElement('div');
                        descriptionDiv.className = 'episode-description';

                        let displayDescription = episode.description.substring(0, 800);
                        if (episode.description.length > 800) {
                            displayDescription += '...';
                        }

                        // Remove any remaining CDATA artifacts client-side as a fallback
                        displayDescription = displayDescription.replace(/\]\]>\s*$/g, '');
                        displayDescription = displayDescription.replace(/\s*\]\]>\s*$/g, '');

                        // Use innerHTML since the description has already been cleaned and is safe
                        descriptionDiv.innerHTML = displayDescription;
                        contentDiv.appendChild(descriptionDiv);
                    }

                    // Audio player
                    // Audio player
                    if (episode.audioUrl) {
                        const audioDiv = document.createElement('div');
                        audioDiv.className = 'episode-audio';

                        const audio = document.createElement('audio');
                        audio.controls = true;

                        const source = document.createElement('source');
                        source.src = episode.audioUrl;
                        source.type = 'audio/mpeg';

                        audio.appendChild(source);
                        audio.appendChild(document.createTextNode('Your browser does not support the audio element.'));
                        audioDiv.appendChild(audio);

                        // Add audio caption
                        const caption = document.createElement('div');
                        caption.className = 'audio-caption';
                        caption.innerHTML = '<font size="1" face="Arial">üéµ Click play to listen!</font>';
                        audioDiv.appendChild(caption);

                        contentDiv.appendChild(audioDiv);
                    }

                    episodeItem.appendChild(contentDiv);

                    // Divider
                    const divider = document.createElement('hr');
                    divider.className = 'episode-divider';
                    episodeItem.appendChild(divider);

                    episodesContainer.appendChild(episodeItem);
                });
            }
        }

        function renderPaginationControls() {
            const pageNumbersContainer = document.getElementById('page-numbers');
            if (!pageNumbersContainer) return;

            const maxVisiblePages = 5;
            let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
            let endPage = Math.min(podcastData.totalPages, startPage + maxVisiblePages - 1);

            if (endPage - startPage + 1 < maxVisiblePages) {
                startPage = Math.max(1, endPage - maxVisiblePages + 1);
            }

            pageNumbersContainer.innerHTML = '';

            for (let i = startPage; i <= endPage; i++) {
                const pageButton = document.createElement('button');
                pageButton.textContent = i;
                pageButton.className = `pagination-link ${i === currentPage ? 'pagination-active' : ''}`;
                pageButton.onclick = () => goToPage(i);
                pageNumbersContainer.appendChild(pageButton);
            }
        }

        function updateButtonStates() {
            const firstPageBtn = document.getElementById('first-page');
            const prevPageBtn = document.getElementById('prev-page');
            const nextPageBtn = document.getElementById('next-page');
            const lastPageBtn = document.getElementById('last-page');

            if (firstPageBtn) firstPageBtn.disabled = currentPage === 1;
            if (prevPageBtn) prevPageBtn.disabled = currentPage === 1;
            if (nextPageBtn) nextPageBtn.disabled = currentPage === podcastData.totalPages;
            if (lastPageBtn) lastPageBtn.disabled = currentPage === podcastData.totalPages;
        }

        function attachEventListeners() {
            const firstPageBtn = document.getElementById('first-page');
            const prevPageBtn = document.getElementById('prev-page');
            const nextPageBtn = document.getElementById('next-page');
            const lastPageBtn = document.getElementById('last-page');

            if (firstPageBtn) firstPageBtn.onclick = () => goToPage(1);
            if (prevPageBtn) prevPageBtn.onclick = () => goToPage(currentPage - 1);
            if (nextPageBtn) nextPageBtn.onclick = () => goToPage(currentPage + 1);
            if (lastPageBtn) lastPageBtn.onclick = () => goToPage(podcastData.totalPages);
        }

        function goToPage(page) {
            if (page < 1 || page > podcastData.totalPages) return;

            currentPage = page;
            renderEpisodes();
            renderPaginationControls();
            updateButtonStates();

            // Update URL without page reload
            const url = new URL(window.location);
            url.searchParams.set('page', page);
            window.history.pushState({}, '', url);
        }

        // Handle browser back/forward buttons
        window.addEventListener('popstate', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const pageParam = urlParams.get('page');
            const page = pageParam ? parseInt(pageParam) : 1;

            if (page !== currentPage && page >= 1 && page <= podcastData.totalPages) {
                currentPage = page;
                renderEpisodes();
                renderPaginationControls();
                updateButtonStates();
            }
        });

        // Initialize
        initializePagination();
    });
</script>